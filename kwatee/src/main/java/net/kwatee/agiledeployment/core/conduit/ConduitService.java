/*
 * ${kwatee_copyright}
 */

package net.kwatee.agiledeployment.core.conduit;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.PostConstruct;

import net.kwatee.agiledeployment.common.exception.InternalErrorException;
import net.kwatee.agiledeployment.conduit.Conduit;
import net.kwatee.agiledeployment.conduit.ConduitFactory;
import net.kwatee.agiledeployment.conduit.ServerInstance;
import net.kwatee.agiledeployment.core.conduit.impl.SshConduitFactory;
import net.kwatee.agiledeployment.core.conduit.impl.TelnetFTPConduitFactory;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class ConduitService {

	final private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(ConduitService.class);
	private Map<String, Class<? extends ConduitFactory>> factories;

	@Value("${kwatee.conduit.conduitFactories:}")
	private String customFactories;

	@PostConstruct
	void initialize() {
		List<String> factoryClassNames = new ArrayList<>();
		factoryClassNames.add(SshConduitFactory.class.getCanonicalName());
		factoryClassNames.add(TelnetFTPConduitFactory.class.getCanonicalName());
		if (StringUtils.isNotEmpty(this.customFactories))
			factoryClassNames.addAll(Arrays.asList(customFactories.split(",")));
		this.factories = new HashMap<>();
		for (String factoryClassName : factoryClassNames) {
			LOG.debug("Registering conduit factory: " + factoryClassName);
			try {
				@SuppressWarnings("unchecked")
				Class<? extends ConduitFactory> factory = (Class<? extends ConduitFactory>) Class.forName(factoryClassName);
				String id = (String) factory.getMethod("getId").invoke(null);
				factory.getMethod("getDisplayName").invoke(null); // to make sure it exists
				this.factories.put(id.toLowerCase(), factory);
			} catch (Throwable e) {
				LOG.error("Failed to register server instance factory: " + factoryClassName, e);
			}
		}
	}

	/**
	 * the conduit factory types available
	 * 
	 * @return the conduit factory types available
	 */
	public Map<String, String> getFactories() {
		Map<String, String> conduitTypes = new HashMap<>(factories.size());
		for (String conduitType : this.factories.keySet()) {
			Class<? extends ConduitFactory> factory = factories.get(conduitType);
			try {
				String label = (String) factory.getMethod("getDisplayName").invoke(null);
				conduitTypes.put(conduitType, label);
			} catch (Exception e) {}
		}
		return conduitTypes;
	}

	/**
	 * The {@link ConduitFactory} object for conduitTypeName
	 * 
	 * @param conduitTypeName
	 *            the conduit factory type name
	 * @return the {@link ConduitFactory} object for <code>conduitTypeName</code>
	 * @throws ConduitException
	 */
	public ConduitFactory getFactory(String conduitTypeName) throws ConduitException {
		Class<? extends ConduitFactory> factory = this.factories.get(conduitTypeName.toLowerCase());
		if (factory != null) {
			try {
				return factory.getConstructor().newInstance();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		throw new ConduitException("ConduitFactory type " + conduitTypeName + " not found");
	}

	/**
	 * A new {@link Conduit} instance generated by the server's {@link ConduitFactory}
	 * 
	 * @param server
	 *            the {@link ServerInstance}
	 * @param conduitType
	 * @param rootDir
	 *            the remote directory where the agent gets installed and the metadata files are located
	 * @return A new {@link Conduit} instance generated by the server's {@link ConduitFactory}
	 * @throws IOException
	 * @throws InterruptedException
	 * @throws ConduitException
	 */
	public Conduit getConduit(ServerInstance server, String conduitType, String rootDir) throws IOException, InterruptedException, ConduitException {
		ConduitFactory conduitFactory = getFactory(conduitType);
		return conduitFactory.getNewInstance(server, rootDir);
	}

	/**
	 * Called when no more connections will be made to the current instance
	 * Clears all potential cached connections to server
	 * 
	 * @param server
	 *            the parent {@link ServerInstance}
	 * @throws ConduitException
	 */
	public void evictServerConduit(ServerInstance server) throws ConduitException {
		try {
			ConduitFactory conduitFactory = getFactory(server.getConduitType());
			conduitFactory.evictServerConnections(server);
		} catch (InternalErrorException e) {}
	}

	/**
	 * Default conduit type for new servers
	 * 
	 * @return the default conduit type
	 */
	public String getDefaultConduitType() {
		return "ssh";
	}
}
